<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Skin Viewer</title>
    <!-- Material Symbols -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-hue: 220;
            --bg-brightness: 0.4;
            --accent-color: hsl(220, 100%, 50%);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Roboto', sans-serif;
            background-color: #000;
        }

        /* Dynamic Background */
        #background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, 
                hsl(var(--bg-hue), 60%, calc(20% * var(--bg-brightness))), 
                hsl(var(--bg-hue), 80%, calc(10% * var(--bg-brightness)))
            );
            filter: blur(20px);
            z-index: 0;
            transition: background 0.1s linear; /* Slight optimization for smooth JS updates */
        }

        /* Canvas */
        #skin_container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: grab;
            outline: none;
        }
        #skin_container:active {
            cursor: grabbing;
        }

        /* UI overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 12px;
            pointer-events: none;
        }

        .icon-btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 48px;
            height: 48px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        /* Floating Tooltip */
        #cursor-tooltip {
            position: fixed;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 1000;
        }

        /* Context Menu */
        #context-menu {
            position: fixed;
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            display: none;
            flex-direction: row; /* Horizontal layout */
            z-index: 100;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            width: 240px;
            height: 90px;
            overflow: hidden;
        }

        .ctx-section {
            flex: 1;
            border-right: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }
        .ctx-section:last-child {
            border-right: none;
        }
        .ctx-section:hover {
            background: rgba(255,255,255,0.1);
        }

        .ctx-label {
            position: absolute;
            bottom: 4px;
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        .ctx-canvas {
            width: 60px;
            height: 60px;
            pointer-events: none;
        }

        .ctx-icon {
            font-size: 32px;
            color: #eee;
        }

        /* Modals */
        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1e1e1e;
            color: white;
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            z-index: 200;
            display: none;
            width: 300px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 150;
            display: none;
        }

        .slider-container {
            margin-bottom: 20px;
            position: relative;
        }
        .slider-container label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #aaa;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            border: 2px solid #fff;
            transition: transform 0.1s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Visibility Toggles in Modal */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }

        #drop-zone {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(90, 118, 243, 0.2);
            border: 4px dashed #5a76f3;
            box-sizing: border-box;
            z-index: 50;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="background"></div>
    <div id="drop-zone">Drop Skin File Here</div>
    <canvas id="skin_container"></canvas>

    <!-- Top UI Buttons -->
    <div id="ui-layer">
        <div class="icon-btn" id="btn-upload" data-tooltip="Upload skin">
            <span class="material-symbols-outlined">frame_person</span>
            <input type="file" id="skin-input" accept="image/*" style="display: none;">
        </div>

        <div class="icon-btn" id="btn-visibility" data-tooltip="Visibility options">
            <span class="material-symbols-outlined">visibility</span>
        </div>

        <div class="icon-btn" id="btn-model-toggle" data-tooltip="Standard">
            <span class="material-symbols-outlined" id="model-icon">boy</span>
        </div>

        <!-- New Perspective/Ortho Toggle -->
        <div class="icon-btn" id="btn-camera-toggle" data-tooltip="Perspective view">
            <span class="material-symbols-outlined" id="camera-icon">crop_free</span>
        </div>

        <div class="icon-btn" id="btn-bg" data-tooltip="Override background">
            <span class="material-symbols-outlined">gradient</span>
        </div>
    </div>

    <!-- Tooltip -->
    <div id="cursor-tooltip"></div>

    <!-- Context Menu -->
    <div id="context-menu">
        <!-- Box 1: Base Layer Preview -->
        <div class="ctx-section" id="ctx-box-1">
            <div id="preview-base" class="ctx-canvas"></div>
            <div class="ctx-label">Base</div>
        </div>
        <!-- Box 2: Overlay Layer Preview -->
        <div class="ctx-section" id="ctx-box-2">
            <div id="preview-overlay" class="ctx-canvas"></div>
            <div class="ctx-label">Overlay</div>
        </div>
        <!-- Box 3: Toggle Both -->
        <div class="ctx-section" id="ctx-box-3">
            <span class="material-symbols-outlined ctx-icon" id="icon-toggle-both">visibility</span>
            <div class="ctx-label">Both</div>
        </div>
    </div>

    <div class="modal-backdrop" id="modal-backdrop"></div>

    <!-- Background Settings Modal -->
    <div class="modal" id="modal-bg">
        <h2>Background Settings</h2>
        <div class="slider-container">
            <label>Hue</label>
            <input type="range" id="bg-hue" min="0" max="360" value="220" step="any">
        </div>
        <div class="slider-container">
            <label>Brightness</label>
            <input type="range" id="bg-brightness" min="0" max="1" step="any" value="0.4">
        </div>
    </div>

    <!-- Global Visibility Modal -->
    <div class="modal" id="modal-visibility">
        <h2>Visibility Options</h2>
        <div id="vis-toggles"></div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/skinview3d@3.0.0-alpha.1/bundles/skinview3d.bundle.js"></script>

    <script>
        // --- 1. Initialization ---
        const skinViewer = new skinview3d.SkinViewer({
            canvas: document.getElementById("skin_container"),
            width: window.innerWidth,
            height: window.innerHeight,
            skin: "https://textures.minecraft.net/texture/b3fbd8d74263672bf62c640e704024345228892f337f7173b2241680183145d8"
        });

        // Config
        let isOrtho = false;
        skinViewer.controls.enableZoom = false; // We handle zoom manually for smoothness
        skinViewer.controls.enableDamping = true;
        skinViewer.controls.dampingFactor = 0.05;

        // --- 2. Camera Switching ---
        const btnCamera = document.getElementById('btn-camera-toggle');
        const iconCamera = document.getElementById('camera-icon');
        let perspCamera = skinViewer.camera; // Save default
        let orthoCamera = new THREE.OrthographicCamera(
            window.innerWidth / -2, window.innerWidth / 2, 
            window.innerHeight / 2, window.innerHeight / -2, 
            0.1, 1000
        );
        
        // Sync Initial Positions
        orthoCamera.position.copy(perspCamera.position);
        orthoCamera.zoom = 40; // Initial ortho zoom
        orthoCamera.updateProjectionMatrix();

        btnCamera.onclick = () => {
            isOrtho = !isOrtho;
            if(isOrtho) {
                // Switch to Ortho
                // Copy orientation
                const dist = skinViewer.camera.position.distanceTo(skinViewer.controls.target);
                orthoCamera.position.copy(skinViewer.camera.position);
                orthoCamera.quaternion.copy(skinViewer.camera.quaternion);
                orthoCamera.zoom = Math.max(20, 1000 / dist); // Approximate zoom conversion
                orthoCamera.updateProjectionMatrix();

                skinViewer.camera = orthoCamera;
                skinViewer.controls.object = orthoCamera;
                
                btnCamera.setAttribute('data-tooltip', 'Orthographic view');
                iconCamera.innerText = 'deployed_code';
            } else {
                // Switch to Perspective
                perspCamera.position.copy(skinViewer.camera.position);
                perspCamera.quaternion.copy(skinViewer.camera.quaternion);
                
                skinViewer.camera = perspCamera;
                skinViewer.controls.object = perspCamera;

                btnCamera.setAttribute('data-tooltip', 'Perspective view');
                iconCamera.innerText = 'crop_free';
            }
            updateTooltip(btnCamera);
        };

        // --- 3. Smooth Zooming ---
        let targetZoom = 40; // For Ortho
        let targetDistance = 30; // For Perspective
        let currentDistance = 30;
        
        // Initialize target from start
        targetDistance = skinViewer.camera.position.distanceTo(skinViewer.controls.target);

        document.getElementById('skin_container').addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY * 0.001; // Sensitivity

            if(isOrtho) {
                // For ortho, we modify camera.zoom
                // Zoom in = value goes UP
                const factor = 1 - delta * 2; 
                targetZoom *= factor;
                targetZoom = Math.min(Math.max(targetZoom, 10), 200);
            } else {
                // For perspective, we modify distance
                const factor = 1 + delta;
                targetDistance *= factor;
                targetDistance = Math.min(Math.max(targetDistance, 10), 100);
            }
        }, { passive: false });

        // Animation Loop for Smooth Zoom & Sliders
        skinViewer.renderer.setAnimationLoop(() => {
            // 1. Damping for Zoom
            if(isOrtho) {
                skinViewer.camera.zoom += (targetZoom - skinViewer.camera.zoom) * 0.1;
                skinViewer.camera.updateProjectionMatrix();
            } else {
                const dist = skinViewer.camera.position.distanceTo(skinViewer.controls.target);
                currentDistance += (targetDistance - currentDistance) * 0.1;
                
                // Apply new distance while keeping direction
                const direction = new THREE.Vector3().subVectors(skinViewer.camera.position, skinViewer.controls.target).normalize();
                skinViewer.camera.position.copy(skinViewer.controls.target).add(direction.multiplyScalar(currentDistance));
            }

            // 2. Smooth Background Update
            updateBackgroundSmooth();

            // Render
            skinViewer.renderer.render(skinViewer.scene, skinViewer.camera);
        });

        // --- 4. Sliders & Background ---
        const sliderHue = document.getElementById('bg-hue');
        const sliderBright = document.getElementById('bg-brightness');
        const bgElement = document.getElementById('background');

        // Targets for lerping
        let targetHue = 220;
        let targetBright = 0.4;
        let currentHue = 220;
        let currentBright = 0.4;

        function updateBackgroundSmooth() {
            // Lerp values
            currentHue += (targetHue - currentHue) * 0.1;
            currentBright += (targetBright - currentBright) * 0.1;

            // Apply to CSS
            document.documentElement.style.setProperty('--bg-hue', currentHue);
            document.documentElement.style.setProperty('--bg-brightness', currentBright);
            document.documentElement.style.setProperty('--accent-color', `hsl(${currentHue}, 100%, 50%)`);
        }

        // Input listeners
        sliderHue.addEventListener('input', (e) => {
            targetHue = parseFloat(e.target.value);
            showSliderTooltip(e.target, `${Math.round(targetHue)}Â°`);
        });
        sliderBright.addEventListener('input', (e) => {
            targetBright = parseFloat(e.target.value);
            showSliderTooltip(e.target, `${Math.round(targetBright * 100)}%`);
        });

        // Slider Tooltips
        function showSliderTooltip(element, text) {
            // Reuse the main tooltip
            const tooltip = document.getElementById('cursor-tooltip');
            const rect = element.getBoundingClientRect();
            tooltip.style.opacity = '1';
            tooltip.innerText = text;
            tooltip.style.left = (rect.left + (rect.width/2) - 10) + 'px';
            tooltip.style.top = (rect.top - 30) + 'px';
        }
        [sliderHue, sliderBright].forEach(el => {
            el.addEventListener('mouseleave', () => document.getElementById('cursor-tooltip').style.opacity = '0');
        });

        // --- 5. Highlighting & Raycasting ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let currentPart = null;
        let highlightMesh = null;

        function getPartName(mesh) {
            // Traverse up to find known group
            let obj = mesh;
            while(obj && obj.parent && obj.parent !== skinViewer.playerObject) {
                obj = obj.parent;
            }
            if(!obj) return null;
            const name = obj.name || mesh.name;
            
            if (name.includes('head')) return 'head';
            if (name.includes('body') || name.includes('torso')) return 'body';
            if (name.includes('leftArm')) return 'leftArm';
            if (name.includes('rightArm')) return 'rightArm';
            if (name.includes('leftLeg')) return 'leftLeg';
            if (name.includes('rightLeg')) return 'rightLeg';
            return null;
        }

        function createHighlight(partName) {
            if(highlightMesh) {
                highlightMesh.parent.remove(highlightMesh);
                highlightMesh.geometry.dispose();
                highlightMesh = null;
            }

            if(!partName) return;

            // Find the geometry to clone. The skin structure usually has the mesh inside the group.
            // We want the OUTER layer geometry if available, or inner if not.
            // Actually, for a highlight, usually boxing the whole part is best.
            // We'll find the specific group in playerObject
            const group = skinViewer.playerObject.children.find(c => (c.name || '').toLowerCase().includes(partName.toLowerCase()));
            
            if(group) {
                // Find the mesh inside
                let targetMesh = null;
                group.traverse(c => {
                    if(c.isMesh) targetMesh = c; // Grab first mesh (usually inner)
                });

                if(targetMesh) {
                    const geom = targetMesh.geometry.clone();
                    const mat = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.15,
                        side: THREE.DoubleSide,
                        depthWrite: false // render on top-ish
                    });
                    highlightMesh = new THREE.Mesh(geom, mat);
                    highlightMesh.scale.set(1.15, 1.15, 1.15); // Scale up slightly to cover outer layer too
                    group.add(highlightMesh);
                }
            }
        }

        document.getElementById("skin_container").addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, skinViewer.camera);
            const intersects = raycaster.intersectObject(skinViewer.playerObject, true);
            
            // Filter out the highlight mesh itself
            const hit = intersects.find(i => i.object !== highlightMesh && i.object.visible);

            if (hit) {
                const part = getPartName(hit.object);
                if (part && part !== currentPart) {
                    currentPart = part;
                    createHighlight(part);
                }
            } else if (currentPart) {
                currentPart = null;
                createHighlight(null);
            }
        });

        // --- 6. Context Menu & 3D Previews ---
        const ctxMenu = document.getElementById('context-menu');
        
        // Preview Renderers (Lazy Init)
        let previewRendererBase, previewRendererOverlay;
        let previewSceneBase, previewSceneOverlay;
        let previewCamera;

        function initPreviewRenderers() {
            if(previewRendererBase) return;

            // Shared Camera for previews
            previewCamera = new THREE.OrthographicCamera(-8, 8, 8, -8, 0.1, 100);
            previewCamera.position.z = 20;

            // Renderer Base
            previewRendererBase = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            previewRendererBase.setSize(60, 60);
            previewRendererBase.setClearColor(0x000000, 0);
            document.getElementById('preview-base').appendChild(previewRendererBase.domElement);
            previewSceneBase = new THREE.Scene();

            // Renderer Overlay
            previewRendererOverlay = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            previewRendererOverlay.setSize(60, 60);
            previewRendererOverlay.setClearColor(0x000000, 0);
            document.getElementById('preview-overlay').appendChild(previewRendererOverlay.domElement);
            previewSceneOverlay = new THREE.Scene();

            // Lighting for previews
            [previewSceneBase, previewSceneOverlay].forEach(s => {
                const amb = new THREE.AmbientLight(0xffffff, 0.8);
                const dir = new THREE.DirectionalLight(0xffffff, 0.5);
                dir.position.set(0, 10, 10);
                s.add(amb);
                s.add(dir);
            });
        }

        function updatePreviews(partName) {
            initPreviewRenderers();

            // Clear old meshes
            const clearScene = (s) => {
                s.children.forEach(c => {
                    if(c.isMesh || c.isGroup) s.remove(c);
                });
            };
            clearScene(previewSceneBase);
            clearScene(previewSceneOverlay);

            // Clone specific part geometries
            // We need to find the Inner and Outer meshes for the part
            // Part naming in skinview3d: 'head', 'headLayer' (or similar logic)
            
            // NOTE: We need the actual Texture from the skinviewer
            const texture = skinViewer.playerObject.skin.head.material.map; // Assuming loaded

            const createClone = (meshName, scene) => {
                const group = skinViewer.playerObject[meshName]; // Access directly if possible, or traverse
                if(!group) return;

                // Clone the mesh inside the group
                group.traverse(c => {
                    if(c.isMesh) {
                        const newGeom = c.geometry.clone();
                        // Reset center
                        newGeom.center(); 
                        
                        const newMat = new THREE.MeshStandardMaterial({ 
                            map: texture, 
                            side: THREE.DoubleSide,
                            transparent: true,
                            alphaTest: 0.5
                        });
                        
                        // Handle UVs if needed (skinview3d maps them correctly on geometry)
                        const mesh = new THREE.Mesh(newGeom, newMat);
                        
                        // Sync rotation: The preview camera is static front. 
                        // We rotate the OBJECT to match the main camera's relative angle.
                        // Actually, simplified: match main player rotation + camera orbit.
                        // Or just copy the quaternion of the player object?
                        // The user wants "matching the current angle of the full skin".
                        
                        // Calculate relative rotation
                        mesh.quaternion.copy(skinViewer.playerObject.quaternion);
                        
                        // Also apply camera orbit rotation inverse?
                        // The main camera moves around. The preview camera is fixed.
                        // To show the same view, we must rotate the mesh by the inverse of the main camera's azimuth/polar?
                        // Easier: Copy main camera position relative to target, normalize, apply to preview camera.
                        
                        scene.add(mesh);
                    }
                });
            }

            // Map logical part to skinview3d property names
            // Properties: head, body, rightArm, leftArm, rightLeg, leftLeg
            // Layers: headLayer, bodyLayer, etc.
            
            createClone(partName, previewSceneBase);
            createClone(partName + "Layer", previewSceneOverlay);

            // Sync Camera Position to match View
            const mainCamPos = skinViewer.camera.position.clone().sub(skinViewer.controls.target);
            mainCamPos.normalize().multiplyScalar(20); // Scale to fit ortho
            previewCamera.position.copy(mainCamPos);
            previewCamera.lookAt(0,0,0);
            previewCamera.updateProjectionMatrix();

            // Render
            previewRendererBase.render(previewSceneBase, previewCamera);
            previewRendererOverlay.render(previewSceneOverlay, previewCamera);
        }

        // Context Menu Event
        document.getElementById("skin_container").addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (currentPart) {
                const rect = ctxMenu.getBoundingClientRect();
                
                // Position fixed at click
                ctxMenu.style.display = 'flex';
                let x = e.clientX;
                let y = e.clientY;
                
                // Bounds check
                if (x + 240 > window.innerWidth) x -= 240;
                if (y + 90 > window.innerHeight) y -= 90;

                ctxMenu.style.left = x + 'px';
                ctxMenu.style.top = y + 'px';

                // Populate Previews
                updatePreviews(currentPart);
                
                // Update "Both" Icon
                const inner = skinViewer.playerObject.skin[currentPart].visible;
                const outer = skinViewer.playerObject.skin[currentPart + "Layer"].visible;
                const icon = document.getElementById('icon-toggle-both');
                
                if (inner && outer) {
                    icon.innerText = 'visibility_off'; // Shows action "Hide"
                } else {
                    icon.innerText = 'visibility'; // Shows action "Show"
                }

                // Store target
                ctxMenu.dataset.target = currentPart;
            }
        });

        // Context Menu Clicks
        document.getElementById('ctx-box-1').onclick = () => {
            const part = ctxMenu.dataset.target;
            const mesh = skinViewer.playerObject.skin[part];
            mesh.visible = !mesh.visible;
            updatePreviews(part); // Re-render to show update? Or just toggle opacity
            // Actually, we just rerender the preview to reflect visibility? 
            // The preview shows the part regardless of visibility usually, but "toggle visibility" implies action on main skin.
            // Let's toggle opacity of the PREVIEW to give feedback, or just keep it visible to show what it IS.
            // Standard UI: The preview shows the part. The click toggles the main skin.
        };
        document.getElementById('ctx-box-2').onclick = () => {
            const part = ctxMenu.dataset.target;
            const mesh = skinViewer.playerObject.skin[part + "Layer"];
            mesh.visible = !mesh.visible;
        };
        document.getElementById('ctx-box-3').onclick = () => {
            const part = ctxMenu.dataset.target;
            const inner = skinViewer.playerObject.skin[part];
            const outer = skinViewer.playerObject.skin[part + "Layer"];
            const bothVisible = inner.visible && outer.visible;
            
            inner.visible = !bothVisible;
            outer.visible = !bothVisible;
            
            // Update icon
            const icon = document.getElementById('icon-toggle-both');
            icon.innerText = bothVisible ? 'visibility' : 'visibility_off';
        };

        // Close context menu
        window.addEventListener('click', (e) => {
            if (!ctxMenu.contains(e.target)) {
                ctxMenu.style.display = 'none';
            }
        });

        // --- 7. Other UI Logic (Copy-Pasted from previous & updated) ---
        
        // Tooltip Helper
        function updateTooltip(element) {
            const tooltip = document.getElementById('cursor-tooltip');
            tooltip.innerText = element.getAttribute('data-tooltip');
        }

        const buttons = document.querySelectorAll('.icon-btn');
        const tooltip = document.getElementById('cursor-tooltip');
        buttons.forEach(btn => {
            btn.addEventListener('mousemove', (e) => {
                tooltip.style.opacity = '1';
                tooltip.innerText = btn.getAttribute('data-tooltip');
                tooltip.style.left = (e.clientX + 10) + 'px';
                tooltip.style.top = (e.clientY + 10) + 'px';
            });
            btn.addEventListener('mouseleave', () => tooltip.style.opacity = '0');
        });

        // File Upload
        document.getElementById('btn-upload').onclick = () => document.getElementById('skin-input').click();
        document.getElementById('skin-input').onchange = (e) => {
            if(e.target.files[0]) loadSkin(e.target.files[0]);
        };

        function loadSkin(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                skinViewer.loadSkin(e.target.result);
                // Reset model to detect automatically or keep current? 
                // skinview3d detects model type from image dimensions usually.
            };
            reader.readAsDataURL(file);
        }

        // Modals
        const backdrop = document.getElementById('modal-backdrop');
        const modalBg = document.getElementById('modal-bg');
        const modalVis = document.getElementById('modal-visibility');

        document.getElementById('btn-bg').onclick = () => {
            modalBg.style.display = 'block';
            backdrop.style.display = 'block';
        };
        
        document.getElementById('btn-visibility').onclick = () => {
            // Populate
            const list = document.getElementById('vis-toggles');
            list.innerHTML = '';
            ['head', 'body', 'leftArm', 'rightArm', 'leftLeg', 'rightLeg'].forEach(part => {
                const row = document.createElement('div');
                row.className = 'toggle-row';
                const isVis = skinViewer.playerObject.skin[part].visible;
                row.innerHTML = `<span>${part}</span><input type="checkbox" ${isVis?'checked':''}>`;
                row.querySelector('input').onchange = (e) => {
                    skinViewer.playerObject.skin[part].visible = e.target.checked;
                    skinViewer.playerObject.skin[part+"Layer"].visible = e.target.checked;
                };
                list.appendChild(row);
            });
            modalVis.style.display = 'block';
            backdrop.style.display = 'block';
        };

        backdrop.onclick = () => {
            modalBg.style.display = 'none';
            modalVis.style.display = 'none';
            backdrop.style.display = 'none';
        };

        // Resize
        window.addEventListener('resize', () => {
            skinViewer.width = window.innerWidth;
            skinViewer.height = window.innerHeight;
            if(isOrtho) {
                orthoCamera.left = window.innerWidth / -2;
                orthoCamera.right = window.innerWidth / 2;
                orthoCamera.top = window.innerHeight / 2;
                orthoCamera.bottom = window.innerHeight / -2;
                orthoCamera.updateProjectionMatrix();
            }
        });

        // Drag Drop
        const dropZone = document.getElementById('drop-zone');
        window.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.style.display = 'flex'; setTimeout(()=>dropZone.style.opacity=1, 10); });
        window.addEventListener('dragleave', (e) => { if(e.target===dropZone) { dropZone.style.opacity=0; setTimeout(()=>dropZone.style.display='none',300); }});
        window.addEventListener('drop', (e) => {
            e.preventDefault(); dropZone.style.opacity=0; dropZone.style.display='none';
            if(e.dataTransfer.files[0]) loadSkin(e.dataTransfer.files[0]);
        });
        window.addEventListener('paste', (e) => {
            const items = (e.clipboardData).items;
            for(let item of items) { if(item.kind==='file') loadSkin(item.getAsFile()); }
        });

    </script>
</body>
</html>
