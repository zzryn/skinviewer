<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Skin Viewer</title>
    <!-- Material Symbols -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-hue: 220;
            --bg-brightness: 0.4;
            --accent-color: hsl(220, 100%, 50%);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Roboto', sans-serif;
            background-color: #000;
        }

        /* Dynamic Background */
        #background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, 
                hsl(var(--bg-hue), 60%, calc(20% * var(--bg-brightness))), 
                hsl(var(--bg-hue), 80%, calc(10% * var(--bg-brightness)))
            );
            filter: blur(20px);
            z-index: 0;
            transition: background 0.1s linear;
        }

        /* Canvas */
        #skin_container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: grab;
            outline: none;
        }
        #skin_container:active {
            cursor: grabbing;
        }

        /* UI overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 12px;
            pointer-events: none;
        }

        .icon-btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 48px;
            height: 48px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        /* Floating Tooltip */
        #cursor-tooltip {
            position: fixed;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 1000;
        }

        /* Context Menu */
        #context-menu {
            position: fixed;
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            display: none;
            flex-direction: row; /* Horizontal layout */
            z-index: 100;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            width: 240px;
            height: 90px;
            overflow: hidden;
        }

        .ctx-section {
            flex: 1;
            border-right: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }
        .ctx-section:last-child {
            border-right: none;
        }
        .ctx-section:hover {
            background: rgba(255,255,255,0.1);
        }

        .ctx-label {
            position: absolute;
            bottom: 4px;
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        .ctx-canvas {
            width: 60px;
            height: 60px;
            pointer-events: none;
        }

        .ctx-icon {
            font-size: 32px;
            color: #eee;
        }

        /* Modals (Refined for Frosted Theme) */
        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            
            /* Dynamic Frosted Background */
            background: hsla(var(--bg-hue), 20%, 15%, 0.85); 
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            
            color: white;
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            z-index: 200;
            display: none;
            width: 300px;
            
            /* Subtle border matching the hue */
            border: 1px solid hsla(var(--bg-hue), 50%, 80%, 0.2);
        }

        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 150;
            display: none;
        }

        .slider-container {
            margin-bottom: 20px;
            position: relative;
        }
        .slider-container label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #aaa;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            border: 2px solid #fff;
            transition: transform 0.1s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Visibility Toggles - Stylized */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 10px 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .toggle-row:hover {
            background: rgba(255,255,255,0.1);
        }
        
        /* Custom Checkbox Styling */
        .custom-checkbox-container {
            position: relative;
            width: 24px;
            height: 24px;
        }
        
        /* Hide default checkbox */
        .toggle-row input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        .custom-checkbox {
            position: absolute;
            top: 0;
            left: 0;
            height: 24px;
            width: 24px;
            background-color: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .toggle-row input:checked ~ .custom-checkbox {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        .custom-checkbox::after {
            content: 'check'; /* Material Icon ligature */
            font-family: 'Material Symbols Outlined';
            font-size: 18px;
            color: white;
            display: none;
        }

        .toggle-row input:checked ~ .custom-checkbox::after {
            display: block;
        }

        #drop-zone {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(90, 118, 243, 0.2);
            border: 4px dashed #5a76f3;
            box-sizing: border-box;
            z-index: 50;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="background"></div>
    <div id="drop-zone">Drop Skin File Here</div>
    <canvas id="skin_container"></canvas>

    <!-- Top UI Buttons -->
    <div id="ui-layer">
        <div class="icon-btn" id="btn-upload" data-tooltip="Upload skin">
            <span class="material-symbols-outlined">frame_person</span>
            <input type="file" id="skin-input" accept="image/*" style="display: none;">
        </div>

        <div class="icon-btn" id="btn-visibility" data-tooltip="Visibility options">
            <span class="material-symbols-outlined">visibility</span>
        </div>

        <div class="icon-btn" id="btn-model-toggle" data-tooltip="Standard">
            <span class="material-symbols-outlined" id="model-icon">boy</span>
        </div>

        <div class="icon-btn" id="btn-camera-toggle" data-tooltip="Perspective view">
            <span class="material-symbols-outlined" id="camera-icon">crop_free</span>
        </div>

        <div class="icon-btn" id="btn-bg" data-tooltip="Override background">
            <span class="material-symbols-outlined">gradient</span>
        </div>
    </div>

    <!-- Tooltip -->
    <div id="cursor-tooltip"></div>

    <!-- Context Menu -->
    <div id="context-menu">
        <div class="ctx-section" id="ctx-box-1">
            <div id="preview-base" class="ctx-canvas"></div>
            <div class="ctx-label">Base</div>
        </div>
        <div class="ctx-section" id="ctx-box-2">
            <div id="preview-overlay" class="ctx-canvas"></div>
            <div class="ctx-label">Overlay</div>
        </div>
        <div class="ctx-section" id="ctx-box-3">
            <span class="material-symbols-outlined ctx-icon" id="icon-toggle-both">visibility</span>
            <div class="ctx-label">Both</div>
        </div>
    </div>

    <div class="modal-backdrop" id="modal-backdrop"></div>

    <!-- Background Settings Modal -->
    <div class="modal" id="modal-bg">
        <h2>Background Settings</h2>
        <div class="slider-container">
            <label>Hue</label>
            <input type="range" id="bg-hue" min="0" max="360" value="220" step="any" data-tooltip-template="{}Â°">
        </div>
        <div class="slider-container">
            <label>Brightness</label>
            <input type="range" id="bg-brightness" min="0" max="1" step="any" value="0.4" data-tooltip-template="{}%">
        </div>
    </div>

    <!-- Global Visibility Modal -->
    <div class="modal" id="modal-visibility">
        <h2>Visibility Options</h2>
        <div id="vis-toggles"></div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/skinview3d@3.0.0-alpha.1/bundles/skinview3d.bundle.js"></script>

    <script>
        // --- 1. Initialization & State ---
        let currentModel = 'default';
        let skinURL = "https://textures.minecraft.net/texture/b3fbd8d74263672bf62c640e704024345228892f337f7173b2241680183145d8";

        const skinViewer = new skinview3d.SkinViewer({
            canvas: document.getElementById("skin_container"),
            width: window.innerWidth,
            height: window.innerHeight,
            skin: skinURL,
            model: currentModel
        });

        // Config
        let isOrtho = false;
        skinViewer.controls.enableZoom = false; 
        skinViewer.controls.enableDamping = true;
        skinViewer.controls.dampingFactor = 0.05;

        // --- 2. File Loading & Model Toggling ---
        function loadSkin(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                skinURL = e.target.result; 
                skinViewer.loadSkin(skinURL, { model: currentModel });
            };
            reader.readAsDataURL(file);
        }

        document.getElementById('btn-upload').onclick = () => document.getElementById('skin-input').click();
        document.getElementById('skin-input').onchange = (e) => { if(e.target.files[0]) loadSkin(e.target.files[0]); };

        const modelBtn = document.getElementById('btn-model-toggle');
        const modelIcon = document.getElementById('model-icon');
        
        modelBtn.onclick = () => {
            if (currentModel === 'default') {
                currentModel = 'slim';
                modelBtn.setAttribute('data-tooltip', 'Slim');
                modelIcon.innerText = 'girl';
            } else {
                currentModel = 'default';
                modelBtn.setAttribute('data-tooltip', 'Standard');
                modelIcon.innerText = 'boy';
            }
            skinViewer.loadSkin(skinURL, { model: currentModel });
            const tooltip = document.getElementById('cursor-tooltip');
            if(tooltip.style.opacity === '1') tooltip.innerText = modelBtn.getAttribute('data-tooltip');
        };


        // --- 3. Camera Switching ---
        const btnCamera = document.getElementById('btn-camera-toggle');
        const iconCamera = document.getElementById('camera-icon');
        let perspCamera = skinViewer.camera; 
        let orthoCamera = new THREE.OrthographicCamera(
            window.innerWidth / -2, window.innerWidth / 2, 
            window.innerHeight / 2, window.innerHeight / -2, 
            0.1, 1000
        );
        
        orthoCamera.position.copy(perspCamera.position);
        orthoCamera.zoom = 40; 
        orthoCamera.updateProjectionMatrix();

        btnCamera.onclick = () => {
            isOrtho = !isOrtho;
            if(isOrtho) {
                const dist = skinViewer.camera.position.distanceTo(skinViewer.controls.target);
                orthoCamera.position.copy(skinViewer.camera.position);
                orthoCamera.quaternion.copy(skinViewer.camera.quaternion);
                orthoCamera.zoom = Math.max(20, 1000 / dist); 
                orthoCamera.updateProjectionMatrix();

                skinViewer.camera = orthoCamera;
                skinViewer.controls.object = orthoCamera;
                
                btnCamera.setAttribute('data-tooltip', 'Orthographic view');
                iconCamera.innerText = 'deployed_code';
            } else {
                perspCamera.position.copy(skinViewer.camera.position);
                perspCamera.quaternion.copy(skinViewer.camera.quaternion);
                
                skinViewer.camera = perspCamera;
                skinViewer.controls.object = perspCamera;

                btnCamera.setAttribute('data-tooltip', 'Perspective view');
                iconCamera.innerText = 'crop_free';
            }
            const tooltip = document.getElementById('cursor-tooltip');
            if(tooltip.style.opacity === '1' && tooltip.innerText.includes('view')) {
                tooltip.innerText = btnCamera.getAttribute('data-tooltip');
            }
        };

        // --- 4. Smooth Zooming ---
        let targetZoom = 40; 
        let targetDistance = 30; 
        let currentDistance = 30;
        targetDistance = skinViewer.camera.position.distanceTo(skinViewer.controls.target);

        document.getElementById('skin_container').addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY * 0.001; 

            if(isOrtho) {
                const factor = 1 - delta * 2; 
                targetZoom *= factor;
                targetZoom = Math.min(Math.max(targetZoom, 10), 200);
            } else {
                const factor = 1 + delta;
                targetDistance *= factor;
                targetDistance = Math.min(Math.max(targetDistance, 10), 100);
            }
        }, { passive: false });

        skinViewer.renderer.setAnimationLoop(() => {
            if(isOrtho) {
                skinViewer.camera.zoom += (targetZoom - skinViewer.camera.zoom) * 0.1;
                skinViewer.camera.updateProjectionMatrix();
            } else {
                const dist = skinViewer.camera.position.distanceTo(skinViewer.controls.target);
                currentDistance += (targetDistance - currentDistance) * 0.1;
                const direction = new THREE.Vector3().subVectors(skinViewer.camera.position, skinViewer.controls.target).normalize();
                skinViewer.camera.position.copy(skinViewer.controls.target).add(direction.multiplyScalar(currentDistance));
            }
            updateBackgroundSmooth();
            skinViewer.renderer.render(skinViewer.scene, skinViewer.camera);
        });

        // --- 5. Sliders & Background ---
        const sliderHue = document.getElementById('bg-hue');
        const sliderBright = document.getElementById('bg-brightness');
        
        let targetHue = 220;
        let targetBright = 0.4;
        let currentHue = 220;
        let currentBright = 0.4;

        function updateBackgroundSmooth() {
            currentHue += (targetHue - currentHue) * 0.1;
            currentBright += (targetBright - currentBright) * 0.1;

            document.documentElement.style.setProperty('--bg-hue', currentHue);
            document.documentElement.style.setProperty('--bg-brightness', currentBright);
            document.documentElement.style.setProperty('--accent-color', `hsl(${currentHue}, 100%, 50%)`);
        }

        function handleSliderInput(slider, valProcessor) {
            const rawVal = parseFloat(slider.value);
            const template = slider.getAttribute('data-tooltip-template');
            const displayVal = valProcessor(rawVal);
            slider.setAttribute('data-current-tooltip', template.replace('{}', displayVal));
            
            if(slider.id === 'bg-hue') targetHue = rawVal;
            if(slider.id === 'bg-brightness') targetBright = rawVal;
            
            updateTooltipState(slider); 
        }

        sliderHue.addEventListener('input', () => handleSliderInput(sliderHue, (v) => Math.round(v)));
        sliderBright.addEventListener('input', () => handleSliderInput(sliderBright, (v) => Math.round(v*100)));

        // --- 6. Tooltip Logic ---
        const tooltip = document.getElementById('cursor-tooltip');
        let mouseX = 0;
        let mouseY = 0;
        window.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            if (tooltip.style.opacity === '1') {
                tooltip.style.left = (mouseX + 15) + 'px';
                tooltip.style.top = (mouseY + 15) + 'px';
            }
        });

        function updateTooltipState(element) {
            let text = '';
            if (element.classList.contains('icon-btn')) {
                text = element.getAttribute('data-tooltip');
            } else if (element.tagName === 'INPUT') {
                text = element.getAttribute('data-current-tooltip');
            }

            if (text) {
                tooltip.innerText = text;
                tooltip.style.opacity = '1';
                tooltip.style.left = (mouseX + 15) + 'px';
                tooltip.style.top = (mouseY + 15) + 'px';
            }
        }

        function hideTooltip() { tooltip.style.opacity = '0'; }

        const tooltipElements = [...document.querySelectorAll('.icon-btn'), sliderHue, sliderBright];
        tooltipElements.forEach(el => {
            el.addEventListener('mouseenter', () => updateTooltipState(el));
            el.addEventListener('mousemove', () => updateTooltipState(el));
            el.addEventListener('mouseleave', hideTooltip);
            if(el.tagName === 'INPUT') {
                 const rawVal = parseFloat(el.value);
                 const template = el.getAttribute('data-tooltip-template');
                 const val = el.id.includes('hue') ? Math.round(rawVal) : Math.round(rawVal*100);
                 el.setAttribute('data-current-tooltip', template.replace('{}', val));
            }
        });


        // --- 7. Highlight & Raycasting ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let currentPart = null;
        let highlightMesh = null;

        function getPartName(mesh) {
            let obj = mesh;
            while(obj && obj.parent && obj.parent !== skinViewer.playerObject) {
                obj = obj.parent;
            }
            if(!obj) return null;
            const name = obj.name || mesh.name;
            
            if (name.includes('head')) return 'head';
            if (name.includes('body') || name.includes('torso')) return 'body';
            if (name.includes('leftArm')) return 'leftArm';
            if (name.includes('rightArm')) return 'rightArm';
            if (name.includes('leftLeg')) return 'leftLeg';
            if (name.includes('rightLeg')) return 'rightLeg';
            return null;
        }

        function createHighlight(partName) {
            if(highlightMesh) {
                highlightMesh.parent.remove(highlightMesh);
                highlightMesh.geometry.dispose();
                highlightMesh = null;
            }
            if(!partName) return;

            const group = skinViewer.playerObject.children.find(c => (c.name || '').toLowerCase().includes(partName.toLowerCase()));
            
            if(group) {
                let targetMesh = null;
                group.traverse(c => { if(c.isMesh) targetMesh = c; });
                if(targetMesh) {
                    const geom = targetMesh.geometry.clone();
                    const mat = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.15,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    highlightMesh = new THREE.Mesh(geom, mat);
                    highlightMesh.scale.set(1.15, 1.15, 1.15); 
                    group.add(highlightMesh);
                }
            }
        }

        document.getElementById("skin_container").addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, skinViewer.camera);
            const intersects = raycaster.intersectObject(skinViewer.playerObject, true);
            const hit = intersects.find(i => i.object !== highlightMesh && i.object.visible);

            if (hit) {
                const part = getPartName(hit.object);
                if (part && part !== currentPart) {
                    currentPart = part;
                    createHighlight(part);
                }
            } else if (currentPart) {
                currentPart = null;
                createHighlight(null);
            }
        });

        // --- 8. Context Menu & Previews ---
        const ctxMenu = document.getElementById('context-menu');
        let previewRendererBase, previewRendererOverlay, previewSceneBase, previewSceneOverlay, previewCamera;

        function initPreviewRenderers() {
            if(previewRendererBase) return;
            previewCamera = new THREE.OrthographicCamera(-8, 8, 8, -8, 0.1, 100);
            previewCamera.position.z = 20;

            previewRendererBase = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            previewRendererBase.setSize(60, 60);
            document.getElementById('preview-base').appendChild(previewRendererBase.domElement);
            previewSceneBase = new THREE.Scene();

            previewRendererOverlay = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            previewRendererOverlay.setSize(60, 60);
            document.getElementById('preview-overlay').appendChild(previewRendererOverlay.domElement);
            previewSceneOverlay = new THREE.Scene();

            [previewSceneBase, previewSceneOverlay].forEach(s => {
                const amb = new THREE.AmbientLight(0xffffff, 0.8);
                const dir = new THREE.DirectionalLight(0xffffff, 0.5);
                dir.position.set(0, 10, 10);
                s.add(amb);
                s.add(dir);
            });
        }

        function updatePreviews(partName) {
            initPreviewRenderers();
            const clearScene = (s) => { s.children.forEach(c => { if(c.isMesh||c.isGroup) s.remove(c); }); };
            clearScene(previewSceneBase);
            clearScene(previewSceneOverlay);

            const texture = skinViewer.playerObject.skin.head.material.map;

            const createClone = (meshName, scene) => {
                const group = skinViewer.playerObject[meshName]; 
                if(!group) return;
                group.traverse(c => {
                    if(c.isMesh) {
                        const newGeom = c.geometry.clone();
                        newGeom.center(); 
                        const newMat = new THREE.MeshStandardMaterial({ 
                            map: texture, side: THREE.DoubleSide, transparent: true, alphaTest: 0.5
                        });
                        const mesh = new THREE.Mesh(newGeom, newMat);
                        mesh.quaternion.copy(skinViewer.playerObject.quaternion);
                        scene.add(mesh);
                    }
                });
            }
            createClone(partName, previewSceneBase);
            createClone(partName + "Layer", previewSceneOverlay);

            const mainCamPos = skinViewer.camera.position.clone().sub(skinViewer.controls.target);
            mainCamPos.normalize().multiplyScalar(20); 
            previewCamera.position.copy(mainCamPos);
            previewCamera.lookAt(0,0,0);
            previewCamera.updateProjectionMatrix();

            previewRendererBase.render(previewSceneBase, previewCamera);
            previewRendererOverlay.render(previewSceneOverlay, previewCamera);
        }

        document.getElementById("skin_container").addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (currentPart) {
                ctxMenu.style.display = 'flex';
                let x = e.clientX;
                let y = e.clientY;
                if (x + 240 > window.innerWidth) x -= 240;
                if (y + 90 > window.innerHeight) y -= 90;
                ctxMenu.style.left = x + 'px';
                ctxMenu.style.top = y + 'px';

                updatePreviews(currentPart);
                
                const inner = skinViewer.playerObject.skin[currentPart].visible;
                const outer = skinViewer.playerObject.skin[currentPart + "Layer"].visible;
                const icon = document.getElementById('icon-toggle-both');
                
                icon.innerText = (inner && outer) ? 'visibility_off' : 'visibility';
                ctxMenu.dataset.target = currentPart;
            }
        });

        document.getElementById('ctx-box-1').onclick = () => {
            const part = ctxMenu.dataset.target;
            const mesh = skinViewer.playerObject.skin[part];
            mesh.visible = !mesh.visible;
            updatePreviews(part);
        };
        document.getElementById('ctx-box-2').onclick = () => {
            const part = ctxMenu.dataset.target;
            const mesh = skinViewer.playerObject.skin[part + "Layer"];
            mesh.visible = !mesh.visible;
            updatePreviews(part);
        };
        document.getElementById('ctx-box-3').onclick = () => {
            const part = ctxMenu.dataset.target;
            const inner = skinViewer.playerObject.skin[part];
            const outer = skinViewer.playerObject.skin[part + "Layer"];
            const bothVisible = inner.visible && outer.visible;
            inner.visible = !bothVisible;
            outer.visible = !bothVisible;
            document.getElementById('icon-toggle-both').innerText = bothVisible ? 'visibility' : 'visibility_off';
            updatePreviews(part);
        };

        window.addEventListener('click', (e) => {
            if (!ctxMenu.contains(e.target)) ctxMenu.style.display = 'none';
        });

        // --- 9. Modal & Stylized Checkboxes ---
        const backdrop = document.getElementById('modal-backdrop');
        const modalBg = document.getElementById('modal-bg');
        const modalVis = document.getElementById('modal-visibility');

        document.getElementById('btn-bg').onclick = () => {
            modalBg.style.display = 'block';
            backdrop.style.display = 'block';
        };
        
        function formatPartName(name) {
            // camelCase to Normal Text (e.g., leftArm -> Left Arm)
            const result = name.replace(/([A-Z])/g, " $1");
            return result.charAt(0).toUpperCase() + result.slice(1);
        }

        document.getElementById('btn-visibility').onclick = () => {
            const list = document.getElementById('vis-toggles');
            list.innerHTML = '';
            
            ['head', 'body', 'leftArm', 'rightArm', 'leftLeg', 'rightLeg'].forEach(part => {
                const row = document.createElement('label'); // Using label for easy click
                row.className = 'toggle-row';
                
                const isVis = skinViewer.playerObject.skin[part].visible;
                
                // Custom checkbox structure
                row.innerHTML = `
                    <span>${formatPartName(part)}</span>
                    <div class="custom-checkbox-container">
                        <input type="checkbox" ${isVis ? 'checked' : ''}>
                        <div class="custom-checkbox"></div>
                    </div>
                `;
                
                const input = row.querySelector('input');
                input.onchange = (e) => {
                    const checked = e.target.checked;
                    // Toggle visibility of both main part and layer
                    skinViewer.playerObject.skin[part].visible = checked;
                    skinViewer.playerObject.skin[part + "Layer"].visible = checked;
                };
                
                list.appendChild(row);
            });
            
            modalVis.style.display = 'block';
            backdrop.style.display = 'block';
        };

        backdrop.onclick = () => {
            modalBg.style.display = 'none';
            modalVis.style.display = 'none';
            backdrop.style.display = 'none';
        };

        // Resize Logic
        window.addEventListener('resize', () => {
            skinViewer.width = window.innerWidth;
            skinViewer.height = window.innerHeight;
            if(isOrtho) {
                orthoCamera.left = window.innerWidth / -2;
                orthoCamera.right = window.innerWidth / 2;
                orthoCamera.top = window.innerHeight / 2;
                orthoCamera.bottom = window.innerHeight / -2;
                orthoCamera.updateProjectionMatrix();
            }
        });

        // Drag/Paste
        const dropZone = document.getElementById('drop-zone');
        window.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.style.display = 'flex'; setTimeout(()=>dropZone.style.opacity=1, 10); });
        window.addEventListener('dragleave', (e) => { if(e.target===dropZone) { dropZone.style.opacity=0; setTimeout(()=>dropZone.style.display='none',300); }});
        window.addEventListener('drop', (e) => {
            e.preventDefault(); dropZone.style.opacity=0; dropZone.style.display='none';
            if(e.dataTransfer.files[0]) loadSkin(e.dataTransfer.files[0]);
        });
        window.addEventListener('paste', (e) => {
            const items = (e.clipboardData).items;
            for(let item of items) { if(item.kind==='file') loadSkin(item.getAsFile()); }
        });

    </script>
</body>
</html>
